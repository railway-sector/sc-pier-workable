"use strict";(self.webpackChunksc_pier_workable=self.webpackChunksc_pier_workable||[]).push([[31450],{46533:(e,t,i)=>{i.d(t,{CW:()=>c,DE:()=>g,GA:()=>_,S1:()=>m,pH:()=>y});var r=i(81806),s=i(76460),n=i(15941),a=i(50346),o=i(47249),l=i(76797),h=i(80963);const u=()=>s.A.getLogger("esri.views.2d.engine.flow.dataUtils"),d=10;async function c(e,t,i,s){const n=performance.now(),l=g(t,i),h=performance.now(),c=m(t,l,i.width,i.height),f=performance.now(),p=function(e,t){const i=new o.A,r=e.reduce((e,t)=>e+t.vertices.length,0),s=new Float32Array(4*r),n=new Array(e.length);let a=0,l=0;for(const{vertices:o}of e){const e=a;for(const t of o)s[4*a]=t.x,s[4*a+1]=t.y,s[4*a+2]=t.t,s[4*a+3]=t.speed,a++;n[l++]={startVertex:e,numberOfVertices:o.length,totalTime:o[o.length-1].t,timeSeed:t?i.getFloat():0}}return{lineVertices:s,lineDescriptors:n}}(c,!0),_=performance.now(),y="Streamlines"===e?function(e,t){const i=9,{lineVertices:r,lineDescriptors:s}=e;let n=0,a=0;for(const g of s)n+=2*g.numberOfVertices,a+=6*(g.numberOfVertices-1);const o=new Float32Array(n*i),l=new Uint32Array(a);let h=0,u=0;function d(){l[u++]=h-2,l[u++]=h,l[u++]=h-1,l[u++]=h,l[u++]=h+1,l[u++]=h-1}function c(e,t,r,s,n,a,l,u){const d=h*i;let c=0;o[d+c++]=e,o[d+c++]=t,o[d+c++]=1,o[d+c++]=r,o[d+c++]=a,o[d+c++]=l,o[d+c++]=s/2,o[d+c++]=n/2,o[d+c++]=u,h++,o[d+c++]=e,o[d+c++]=t,o[d+c++]=-1,o[d+c++]=r,o[d+c++]=a,o[d+c++]=l,o[d+c++]=-s/2,o[d+c++]=-n/2,o[d+c++]=u,h++}for(const g of s){const{totalTime:e,timeSeed:i}=g;let s=null,n=null,a=null,o=null,l=null,h=null;for(let u=0;u<g.numberOfVertices;u++){const f=r[4*(g.startVertex+u)],p=r[4*(g.startVertex+u)+1],m=r[4*(g.startVertex+u)+2],_=r[4*(g.startVertex+u)+3];let y=null,w=null,v=null,T=null;if(u>0){y=f-s,w=p-n;const r=Math.sqrt(y*y+w*w);if(y/=r,w/=r,u>1){let e=y+l,i=w+h;const r=Math.sqrt(e*e+i*i);e/=r,i/=r;const s=Math.min(1/(e*y+i*w),t);e*=s,i*=s,v=-i,T=e}else v=-w,T=y;null!==v&&null!==T&&(c(s,n,a,v,T,e,i,_),d())}s=f,n=p,a=m,l=y,h=w,o=_}c(s,n,a,-h,l,e,i,o)}return{vertexData:o,indexData:l}}(p,d):function(e){const t=16,i=1,r=2,{lineVertices:s,lineDescriptors:n}=e;let a=0,o=0;for(const V of n){const e=V.numberOfVertices-1;a+=4*e*2,o+=6*e*2}const l=new Float32Array(a*t),h=new Uint32Array(o);let u,d,c,g,f,p,m,_,y,w,v,T,M,S,x=0,b=0;function R(){h[b++]=x-8,h[b++]=x-7,h[b++]=x-6,h[b++]=x-7,h[b++]=x-5,h[b++]=x-6,h[b++]=x-4,h[b++]=x-3,h[b++]=x-2,h[b++]=x-3,h[b++]=x-1,h[b++]=x-2}function A(e,s,n,a,o,h,u,d,c,g,f,p,m,_){const y=x*t;let w=0;for(const t of[i,r])for(const i of[1,2,3,4])l[y+w++]=e,l[y+w++]=s,l[y+w++]=n,l[y+w++]=a,l[y+w++]=u,l[y+w++]=d,l[y+w++]=c,l[y+w++]=g,l[y+w++]=t,l[y+w++]=i,l[y+w++]=m,l[y+w++]=_,l[y+w++]=o/2,l[y+w++]=h/2,l[y+w++]=f/2,l[y+w++]=p/2,x++}function C(e,t){let i=y+v,r=w+T;const s=Math.sqrt(i*i+r*r);i/=s,r/=s;const n=y*i+w*r;i/=n,r/=n;let a=v+M,o=T+S;const l=Math.sqrt(a*a+o*o);a/=l,o/=l;const h=v*a+T*o;a/=h,o/=h,A(u,d,c,g,-r,i,f,p,m,_,-o,a,e,t),R()}function L(e,t,i,r,s,n){if(y=v,w=T,v=M,T=S,null==y&&null==w&&(y=v,w=T),null!=f&&null!=p){M=e-f,S=t-p;const i=Math.sqrt(M*M+S*S);M/=i,S/=i}null!=y&&null!=w&&C(s,n),u=f,d=p,c=m,g=_,f=e,p=t,m=i,_=r}function k(e,t){y=v,w=T,v=M,T=S,null==y&&null==w&&(y=v,w=T),null!=y&&null!=w&&C(e,t)}for(const V of n){u=null,d=null,c=null,g=null,f=null,p=null,m=null,_=null,y=null,w=null,v=null,T=null,M=null,S=null;const{totalTime:e,timeSeed:t}=V;for(let i=0;i<V.numberOfVertices;i++)L(s[4*(V.startVertex+i)],s[4*(V.startVertex+i)+1],s[4*(V.startVertex+i)+2],s[4*(V.startVertex+i)+3],e,t);k(e,t)}return{vertexData:l,indexData:h}}(p),w=performance.now();return(0,r.A)("esri-2d-profiler")&&(u().info("I.1","_createFlowFieldFromData (ms)",Math.round(h-n)),u().info("I.2","_getStreamlines (ms)",Math.round(f-h)),u().info("I.3","createAnimatedLinesData (ms)",Math.round(_-f)),u().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(w-_)),u().info("I.5","createFlowMesh (ms)",Math.round(w-n)),u().info("I.6","Mesh size (bytes)",y.vertexData.buffer.byteLength+y.indexData.buffer.byteLength)),await Promise.resolve(),(0,a.Te)(s),y}function g(e,t){const i=function(e,t,i,r){if(0===r)return e;const s=Math.round(3*r),n=new Array(2*s+1);let a=0;for(let h=-s;h<=s;h++){const e=Math.exp(-h*h/(r*r));n[h+s]=e,a+=e}for(let h=-s;h<=s;h++)n[h+s]/=a;const o=new Float32Array(e.length);for(let h=0;h<i;h++)for(let i=0;i<t;i++){let r=0,a=0;for(let o=-s;o<=s;o++){if(i+o<0||i+o>=t)continue;const l=n[o+s];r+=l*e[2*(h*t+(i+o))],a+=l*e[2*(h*t+(i+o))+1]}o[2*(h*t+i)]=r,o[2*(h*t+i)+1]=a}const l=new Float32Array(e.length);for(let h=0;h<t;h++)for(let e=0;e<i;e++){let r=0,a=0;for(let l=-s;l<=s;l++){if(e+l<0||e+l>=i)continue;const u=n[l+s];r+=u*o[2*((e+l)*t+h)],a+=u*o[2*((e+l)*t+h)+1]}l[2*(e*t+h)]=r,l[2*(e*t+h)+1]=a}return l}(t.data,t.width,t.height,e.smoothing);return e.interpolate?(e,r)=>{const s=Math.floor(e),n=Math.floor(r);if(s<0||s>=t.width)return[0,0];if(n<0||n>=t.height)return[0,0];const a=e-s,o=r-n,l=s,h=n,u=s<t.width-1?s+1:s,d=n<t.height-1?n+1:n,c=i[2*(h*t.width+l)],g=i[2*(h*t.width+u)],f=i[2*(d*t.width+l)],p=i[2*(d*t.width+u)],m=i[2*(h*t.width+l)+1],_=i[2*(h*t.width+u)+1];return[(c*(1-o)+f*o)*(1-a)+(g*(1-o)+p*o)*a,(m*(1-o)+i[2*(d*t.width+l)+1]*o)*(1-a)+(_*(1-o)+i[2*(d*t.width+u)+1]*o)*a]}:(e,r)=>{const s=Math.round(e),n=Math.round(r);return s<0||s>=t.width||n<0||n>=t.height?[0,0]:[i[2*(n*t.width+s)],i[2*(n*t.width+s)+1]]}}function f(e,t,i,r,s,a,o,l){const h=[],{raster:u,width:d,height:c,resolutionFactor:g}=l;let f=r,p=s,m=0,[_,y]=i(f,p);_*=t.velocityScale,y*=t.velocityScale;const w=Math.sqrt(_*_+y*y);let v,T;h.push({x:f,y:p,t:m,speed:w});for(let M=0;M<t.verticesPerLine;M++){let[r,s]=i(f,p);r*=t.velocityScale,s*=t.velocityScale;const l=Math.sqrt(r*r+s*s);if(l<t.minSpeedThreshold)return h;const _=e*r/l,y=e*s/l;if(f+=_*t.segmentLength,p+=y*t.segmentLength,t.wrapAround&&(f=(0,n.OS)(f,a[0])),m+=e*t.segmentLength/l,Math.acos(_*v+y*T)>t.maxTurnAngle)return h;if(t.collisions){let e=Math.round(f*g);const i=Math.round(p*g);if(t.wrapAround&&(e=(0,n.OS)(e,d)),e<0||e>d-1||i<0||i>c-1)return h;const r=u[i*d+e];if(-1!==r&&r!==o)return h;u[i*d+e]=o}h.push({x:f,y:p,t:m,speed:l}),v=_,T=y}return h}function p(e,t,i,r,s,n,a,o){const l=Math.round((.2+.6*a.getFloat())*e.verticesPerLine),h=e.verticesPerLine-l,u=f(-1,{...e,verticesPerLine:h},t,i,r,s,n,o),d=f(1,{...e,verticesPerLine:l},t,i,r,s,n,o),c=u.reverse();return c.splice(-1,1),c.concat(d)}function m(e,t,i,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{positions:[]};if(e.density<=0)return[];const{positions:n}=s,a=[],l=new o.A,h=1/Math.max(e.lineCollisionWidth,1),u=Math.round(i*h),d=Math.round(r*h),c=new Int32Array(u*d);for(let o=0;o<c.length;o++)c[o]=-1;const g={raster:c,width:u,height:d,resolutionFactor:h},m={},_=e.lineSpacing/Math.sqrt(e.density),y=Math.floor(r/_),w=Math.floor(i/_);for(let o=0;o<y;o++){const e=o*_;for(let t=0;t<w;t++){const i=t*_;m[`${t}-${o}`]={x:i,y:e,positions:[]}}}for(const{x:o,y:f}of n){const e=m[`${Math.floor(o/_)}-${Math.floor(f/_)}`];e&&e.positions.push([o,f])}const v=[];for(const o in m){const e=m[o];if(0===e.positions.length)v.push({x:e.x+_/2,y:e.y+_/2,sort:.66+.33*l.getFloat(),stage:0});else{const[t]=e.positions.splice(0,1);v.push({x:t[0],y:t[1],sort:.33*l.getFloat(),stage:1});for(const[i,r]of e.positions)v.push({x:i,y:r,sort:.33+.33*l.getFloat(),stage:2})}}v.sort((e,t)=>e.sort-t.sort);for(const{x:o,y:T,stage:M}of v){const s=e.onlyForwardTracing?f(1,e,t,o,T,[i,r],a.length,g):p(e,t,o,T,[i,r],a.length,l,g);s.length<2||a.push({stage:M,vertices:s})}return a}function _(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.width,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.height,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=t.pixels,l=i*r,h=new Float32Array(2*l),u=t.width,d=(e,t)=>e+s+(t+a)*u,c=(e,t)=>e+t*i;let g;if(null!=t.mask)if(i!==t.width||r!==t.height||0!==s||0!==a){g=new Uint8Array(2*l);const e=t.mask;for(let t=0;t<r;++t)for(let r=0;r<i;++r){const i=d(r,t),s=c(r,t);g[2*s]=e[2*i],g[2*s+1]=e[2*i+1]}}else g=t.mask;else g=new Uint8Array(2*l),g.fill(255);if("vector-uv"===e)for(let n=0;n<r;++n)for(let e=0;e<i;++e){const t=d(e,n),i=c(e,n);h[2*i]=o[0][t],h[2*i+1]=-o[1][t]}else if("vector-magdir"===e){const{cos:e,sin:t}=Math;for(let s=0;s<r;++s)for(let r=0;r<i;++r){const i=d(r,s),a=c(r,s),l=o[0][i],u=(0,n.kU)(o[1][i]),g=e(u-Math.PI/2),f=t(u-Math.PI/2);h[2*a]=g*l,h[2*a+1]=f*l}}return{data:h,mask:g,width:i,height:r}}async function y(e,t,i,s,n,a){const o=performance.now(),d=(0,h.Vp)(t.spatialReference);if(!d){const l=await w(e,t,i,s,n,a);return(0,r.A)("esri-2d-profiler")&&u().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-o)),(0,r.A)("esri-2d-profiler")&&u().info("I.9","Number of parts",1),l}const[c,g]=d.valid,f=g-c,p=Math.ceil(t.width/f),m=t.width/p,_=Math.round(i/p);let y=t.xmin;const v=[],T=performance.now();for(let r=0;r<p;r++){const i=new l.A({xmin:y,xmax:y+m,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference});v.push(w(e,i,_,s,n,a)),y+=m}const M=await Promise.all(v);if((0,r.A)("esri-2d-profiler")&&u().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-T)),(0,r.A)("esri-2d-profiler")&&u().info("I.9","Number of parts",M.length),1===M.length)return(0,r.A)("esri-2d-profiler")&&u().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-o)),M[0];const S={data:new Float32Array(i*s*2),mask:new Uint8Array(i*s),width:i,height:s};let x=0;for(const r of M){for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++)x+t>=i||(S.data[2*(e*i+x+t)]=r.data[2*(e*r.width+t)],S.data[2*(e*i+x+t)+1]=r.data[2*(e*r.width+t)+1],S.mask[e*i+x+t]=r.mask[e*r.width+t]);x+=r.width}return(0,r.A)("esri-2d-profiler")&&u().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-o)),S}async function w(e,t,i,r,s,n){const a={requestProjectedLocalDirections:!0,signal:n};if(null!=s&&(a.timeExtent=s),"imagery"===e.type){await e.load({signal:n});const s=await e.internalFetchImage(t,i,r,a);return null==s?.pixelData?.pixelBlock?{data:new Float32Array(i*r*2),mask:new Uint8Array(i*r),width:i,height:r}:_(e.rasterInfo.dataType,s.pixelData.pixelBlock)}await e.load({signal:n});const o=await e.fetchPixels(t,i,r,a);return null==o?.pixelBlock?{data:new Float32Array(i*r*2),mask:new Uint8Array(i*r),width:i,height:r}:_(e.serviceRasterInfo.dataType,o.pixelBlock)}},64147:(e,t,i)=>{i.d(t,{$7:()=>h,Ci:()=>f,Cq:()=>p,FO:()=>u,NK:()=>c,S$:()=>r,iM:()=>g,jt:()=>n,nD:()=>l,q6:()=>a,q7:()=>o,ti:()=>d,um:()=>s});const r=.1,s=1,n=1,a=1e3,o=!1,l=3,h=1,u=1.5,d=501,c=256,g=3,f=2,p=2},89214:(e,t,i)=>{i.d(t,{A:()=>Y});var r=i(6326),s=i(18690),n=(i(81806),i(30726)),a=i(50346),o=i(68134),l=i(52394),h=i(91417),u=i(31633),d=i(46053),c=(i(76460),i(87990)),g=i(34111),f=i(56611),p=i(2413),m=i(80963),_=i(731),y=i(66917),w=i(69576),v=i(1873),T=i(64147),M=i(3109),S=i(12016);class x extends S.B{constructor(e){super("FlowWorker","generateStreamlines",{generateStreamlines:e=>[e.flowData.data.buffer,e.flowData.mask.buffer],generateTiledStreamlines:e=>{const t=[];return e.flowDataTiles.forEach(e=>{"loaded"===e.type&&t.push(e.data.data.buffer,e.data.mask.buffer)}),t}},e,{strategy:"dedicated"})}generateStreamlines(e,t){return this.invokeMethod("generateStreamlines",e,t)}generateTiledStreamlines(e,t){return this.invokeMethod("generateTiledStreamlines",e,t)}}var b=i(69539),R=i(9392),A=i(75002),C=i(94587),L=i(12482),k=i(63048),V=i(70667),P=i(31723),F=i(1599);function D(e,t,i,r,s,n){let{vertices:a,stage:o,hasMagnitude:l}=i;const{spatialReference:h}=t.extent,u=[],d=(0,P.uu)(l),c=t.flowExtentInfo.modelSize[0];let g=0;for(let S=0;S<a.length;S+=d){if(n&&S>0){const e=a[S]-a[S-d];e>c/2?g-=c:-e>c/2&&(g+=c)}const[i,s]=t.modelToMapSpace(a[S]+g,a[S+1],!1),o=n?[i,s,F.bi]:I(i,s,h,e,r);u.push(o)}const f=Math.floor(a.length/d),p=(0,C.fY)(f);for(let S=0;S<f;S++)p[S]=a[S*d+2];const{hasVVColor:m,hasVVOpacity:_,hasVVSize:y}=s.parameters;let w,v,T;if(l&&(m||_||y)){const e=(0,A.oe)(f);for(let t=0;t<f;t++)e[t]=a[t*d+3];m&&(w=[e]),_&&(v=[e]),y&&(T=[e])}const M=(0,V.yU)([u],void 0,[{timeStamps:p,streamlineType:o}],w,v,T);return(0,V.te)(s,M[0])}function q(e,t,i){if(null==e)return{};let r=null;if(e.visualVariables){const t=[],i=e.visualVariables,s=new k.wI({supports:{size:!0,color:!0,rotation:!1,opacity:!0}});r=(0,k.T3)(i,s,t)}const s=r?.color?[1,1,1,1]:b.A.toUnitRGBA(e.color);return s[3]*=t,{color:s,width:e.trailWidth,cap:0,animationSpeed:e.flowSpeed,trailLength:e.trailLength,animation:3,emissiveStrength:i,vvColor:r?.color,vvOpacity:r?.opacity,vvSize:r?.size}}function I(e,t,i,r,s){const{absoluteZ:n}=(0,L.Q5)(e,t,0,i,r,s),a=(0,R.fA)(e,t,n);return r.renderCoordsHelper.toRenderCoords(a,i,a),a}var Z=i(48989),O=i(97255);class E{constructor(e,t,i,r,s){this._query=e,this.streamlines=t,this._material=i,this.geometries=r,this._bytesPerFeature=s,this._startTime=0,this._endTime=1/0,this.usedMemory=null,this.startTime=this._query.time,this.computeMemory()}computeMemory(){const e=(0,O.Qh)(this.streamlines),t=(0,O.Qh)(this.geometries.map(e=>e.attributes)),i=this.streamlines.length*this._bytesPerFeature;this.usedMemory=e+t+i}get startTime(){return this._startTime}set startTime(e){this._query.time!==e&&(this._query=new M.y6(this._query.extent,this._query.timeExtent,this._query.size,this._query.pixelRatio,(0,h.Kp)(e))),this._startTime=e,this.setMaterialParameters({startTime:e})}get endTime(){return this._endTime}set endTime(e){this._endTime=e,this.setMaterialParameters({endTime:e})}get query(){return this._query}hasFadedOut(e){return this.endTime+this._material.parameters.fadeOutTime<e}setMaterialParameters(e){this._material.setParameters(e)}get test(){return null}}var G=i(442),U=i(59752);class W extends E{constructor(e,t,i,r,s){super(e,t,i,r,Z.Fq.LINE_ROUND.draped.bytesPerFeature),this._layerView=s,this._drapeRenderer=null,this.drapeSourceType=2,this.updatePolicy=0,this.renderGroup=0,this._frameTask=null,this._renderGeometries=[]}get _view(){return this._layerView.view}get layer(){return this._layerView.layer}get fullOpacity(){return this._layerView.fullOpacity}get attached(){return null!=this._drapeRenderer}get destroyed(){return this.attached}async attach(){const{geometries:e}=this;null!=e&&(this.detach(),this._frameTask=this._view.resourceController.scheduler.registerTask(U.W6.FLOW_GENERATOR),await this._frameTask.scheduleGenerator(t=>this._addGeometryToOverlay(e,t)))}async*_addGeometryToOverlay(e,t){this._drapeRenderer=this._view.overlayManager.registerGeometryDrapeSource(this);for(let i=0;i<e.length;i+=T.ti){const r=e.slice(i,i+T.ti).map(e=>new G.$(e));this._drapeRenderer.addGeometries(r,0),this._renderGeometries.push(...r),this._drapeRenderer.commitChanges(),t.madeProgress(),t.done&&(t=yield)}}detach(){this._frameTask=(0,n.xt)(this._frameTask),this._drapeRenderer&&(this._drapeRenderer.removeGeometries(this._renderGeometries,2),this._drapeRenderer.commitChanges(),this._renderGeometries.length=0),this.attached&&this._view.overlayManager.unregisterDrapeSource(this),this._drapeRenderer=(0,n.pR)(this._drapeRenderer)}}var B=i(37046),j=i(8918);class z extends E{constructor(e,t,i,r,s){super(e,t,i,r,Z.Fq.LINE_ROUND.bytesPerFeature),this._view=s,this._objects3D=[],this._engineLayer=null,this._frameTask=null}get attached(){return null!=this._engineLayer}async attach(){const{geometries:e}=this;null!=e&&(this.detach(),this._frameTask=this._view.resourceController.scheduler.registerTask(U.W6.FLOW_GENERATOR),await this._frameTask.scheduleGenerator(t=>this._addGeometryToLayer(e,t)))}detach(){this.attached&&(this._engineLayer?.removeMany(this._objects3D),this._objects3D.forEach(e=>e.dispose()),this._engineLayer?.commit(),this._objects3D=[],this._engineLayer=null,this._frameTask=(0,n.xt)(this._frameTask))}async*_addGeometryToLayer(e,t){const{stage:i}=this._view,r=new j.x(i,{pickable:!1,updatePolicy:1});for(let s=0;s<e.length;s+=T.ti){const i=new B.B({geometries:e.slice(s,s+T.ti),castShadow:!1});r.add(i),this._objects3D.push(i),r.commit(),t.madeProgress(),t.done&&(t=yield)}this._engineLayer=r}}var H=i(9902),N=i(12028),$=i(52479),K=i(90992);let Y=class extends w.A{constructor(e){super(e),this.type="flow",this.renderedTiles=null,this.requireLoad=!1,this.workerHandle=null,this.frameTask=null,this._averageLoadingTime=(0,h.Kp)(0),this._abortController=null,this._loadingState="ready-to-load",this._tilesUpdateIsWaiting=!1,this._debugAllowAutoLoading=!0,this.emissiveStrength=0,this._overrideMaterialParameters=null,this._overrideSimulationSettings=null,this._overrideTransitionEnabled=null,this._updateTask=null,this._debouncedTileUpdate=(0,a.sg)(async()=>{const{allTiles:e}=this.surface,t=this._getTileFilterFunction(),i=new Set;await this.frameTask.scheduleGenerator(function*(r){for(let s=0;s<e.length;++s){const n=e.at(s);t(n)&&i.add(n),r.madeProgress(),r.done&&(r=yield)}}),this.renderedTiles=i})}initialize(){const{surface:e,view:t}=this,{resourceController:i}=t;this.workerHandle=new x((0,v.m)(i)),this.frameTask=i.scheduler.registerTask(U.W6.FLOW_GENERATOR),this._updateTask=(0,l.mg)({update:e=>this._update(e)}),this.addHandles([(0,o.wB)(()=>this._simulationSettings,()=>this.triggerLoad(),{sync:!0,equals:(e,t)=>null==e&&null==t||null!=e&&null!=t&&(0,y.r$)(e,t)}),(0,o.wB)(()=>{const{elevationInfo:e}=this;return[this._clippingArea,this._visible,this._draped,this.view.state.contentPixelRatio,this.view.viewingMode,e?.mode,e?.offset,e?.unit,this._effectiveDensity]},()=>this.triggerLoad(),o.OH),(0,o.wB)(()=>this._materialParameters,e=>{this._resources?.setMaterialParameters(e),this._lastResources?.setMaterialParameters(e)}),e.on("tiles-changed",()=>{this.loadByTileTreesAllowed&&this._triggerTilesUpdate()}),t.enableFeatureTiles(),(0,o.wB)(()=>[this._dataBounds,this._featureTilesBounds,this.loadAllTiles],()=>this._triggerTilesUpdate()),(0,o.wB)(()=>this._flowRenderer,(e,t)=>{const i=t?.visualVariables??[],r=e?.visualVariables??[];r.length===i.length&&r.every((e,t)=>e.type===i[t].type)||this.clear()}),(0,o.z7)(()=>!t.featureTiles?.updating,()=>{this.loadByTileTreesAllowed&&this._triggerTilesUpdate()})]),this._triggerTilesUpdate()}destroy(){this._updateTask=(0,n.xt)(this._updateTask),this.abort(),this.clear()}abort(){this._abortController=(0,n.DC)(this._abortController),this.requireLoad=!1}get _clippingArea(){const e=(0,f.projectOrLoad)(this.view.clippingArea,this.surface.spatialReference).geometry;return null==e?null:(0,p.VY)(e)}get _dataBounds(){const e=(0,f.projectOrLoad)(this.layer.fullExtent,this.surface.spatialReference).geometry;return null==e?null:(0,p.VY)(e)}get _draped(){return"on-the-ground"===this.elevationInfo.mode}get _ellipsoidRadius(){return(0,g.tO)(this.view.spatialReference).radius}get extent(){const{spatialReference:e}=this.surface;let t=this.renderedTiles;if(null==e||null==t)return null;const i=this.view.terrainLevel;if(null!=i){const e=new Set;t.forEach(t=>{Math.abs(i-t.level)<T.iM&&e.add(t)}),t=e}const r=(0,P.DW)(t,this.spatialReferenceInfo);return null==r?null:((0,p.E$)(r,this._clippingArea,r),(0,p.w1)(r,e))}get loadAllTiles(){const{position:e}=this.view.camera,t=e.z;return null!=t&&t*(0,u.G9)(e.spatialReference)/this._ellipsoidRadius>=T.FO}get isDataGlobal(){const{extent:e,spatialReferenceInfo:t}=this;return null!=e&&(0,M.iE)(e.xmin,e.xmax,t)}get loadByTileTreesAllowed(){return!this.loadAllTiles||!this.loadRequirementsMet}get _featureTilesBounds(){const e=this.view.featureTiles?.filterExtent,t=(0,f.projectOrLoad)(e,this.surface.spatialReference).geometry;return null==t?null:(0,p.VY)(t)}get _flowRenderer(){const e=this.layer.renderer;return"flow"!==e?.type?null:e}get _materialParameters(){return{...q(this._flowRenderer,this.layerView.fullOpacity,this.emissiveStrength),fadeInTime:T.jt,fadeOutTime:T.um,...this._overrideMaterialParameters,hasSlicePlane:this.layerView.slicePlaneEnabled,screenSizePerspective:!this._draped&&(0,N.tl)(this.layer.screenSizePerspectiveEnabled)?this.view.screenSizePerspective.parameters:null}}get _opacity(){return this.layerView.fullOpacity}get _seamlessTransitionWaitingTime(){const{_averageLoadingTime:e}=this;return(0,h.Kp)(0===e?T.$7:this._averageLoadingTime*T.nD)}get _seamlessTransitionEnabled(){return null!=this._overrideTransitionEnabled?this._overrideTransitionEnabled:T.q7}get _tracingResolution(){const{extent:e}=this;if(!e)return[0,0];const t=(0,M.Wn)(e.xmin,e.xmax,this.spatialReferenceInfo?.valid)/(e.ymax-e.ymin),[i,r]=this.view.size;let s,n;i<r?(s=i,n=i/t):(s=r*t,n=r);const a=T.NK,o=this.view.qualitySettings.flow3D.maxTracingResolution,l=Math.max(1,a/Math.min(s,n)),h=l*Math.min(1,o/Math.max(s*l,n*l));return[Math.round(s*h),Math.round(n*h)]}get _visible(){const e=this._flowRenderer?.color;return this.visibleAtCurrentScale&&this.layer.effectiveVisible&&this._opacity>0&&(null==e||e.a>0)}get _estimatedStreamlines(){const{extent:e,_simulationSettings:t,renderedTiles:i}=this;if(null==t||null==i)return 0;const r=this._tracingResolution[0]*this._tracingResolution[1]/t.lineSpacing**2*t.density,s=null==e?null:(0,p.VY)(e);if(null==s)return 0;let n=0;for(const l of i)(0,p.gR)(s,l.extent)&&(n+=(0,p.Wc)(l.extent));const a=(0,p.Wc)(s),o=0===a?0:n/a;return 2*Math.round(r*o)}get _effectiveDensity(){const{_estimatedStreamlines:e,_simulationSettings:t}=this,{qualitySettings:i,quality:r}=this.view;if(null==t)return 0;const s=i.flow3D.maxTotalNumberOfStreamlines,n=e>=s?s/e:1,a=t.density*n*r;return t.lineSpacing/Math.sqrt(a)<t.lineCollisionWidth?(t.lineSpacing/t.lineCollisionWidth)**2:a}get elevationInfo(){return this.layer.elevationInfo??Q}startPositions(e){if(!this._seamlessTransitionEnabled)return[];const{_flowRenderer:t,_resources:i}=this;return null==t||null==i?[]:(0,y.Dt)(i.streamlines,i.query,e,t.flowSpeed)}get needsMagnitude(){return this._flowRenderer?.hasVisualVariables()??!1}get spatialReferenceInfo(){return(0,m.Vp)(this.surface.spatialReference)}get layer(){return this.layerView.layer}get loadingState(){return this._loadingState}get loadRequirementsMet(){return null!=this.renderedTiles&&this.renderedTiles.size>0}getUpdating(){return this.updatingHandles.updating||this.requireLoad||"before-transition"===this._loadingState}get updating(){return this.getUpdating()}get visibleAtCurrentScale(){return!(0,K.j)()||(0,K.E5)(this.layer.effectiveScaleRange,this.view.scale)}get _simulationSettings(){const{_flowRenderer:e,_overrideSimulationSettings:t}=this;if(null==e)return null;let i=(0,y.hq)(e);return i.segmentLength=i.lineCollisionWidth/2,i.onlyForwardTracing=!1,i.density*=T.Ci,this.loadAllTiles&&this.isDataGlobal&&(i.density*=T.Cq),null!=t&&(i={...i,...t}),i}getSimulationSettings(e){const{_simulationSettings:t,spatialReferenceInfo:i}=this;if(null==t)return null;const r="global"===this.view.viewingMode&&null!=i&&(0,M.iE)(e.extent.xmin,e.extent.xmax,i);return{...t,wrapAround:r,density:this._effectiveDensity}}get surface(){return this.view.basemapTerrain}doRefresh(){this.triggerLoad()}clear(){this._resources?.detach(),this._resources=null,this._lastResources?.detach(),this._lastResources=null,this._loadingState="ready-to-load"}_update(e){const t=(0,h.y)(e.time);this._lastResources?.hasFadedOut(t)&&this._lastResources.detach();const i=this._nextStateForTransition(t);if(!this.requireLoad||this.updatingHandles.updating||"ready-to-load"!==i||!this.loadRequirementsMet)return void(this._loadingState=i);this._loadingState="loading";this.updatingHandles.addPromise((0,a.QZ)((async()=>{const e=performance.now(),i=this._seamlessTransitionEnabled&&null!=this._resources?(0,h.Kp)(t+this._seamlessTransitionWaitingTime):t;await this._load(i);const r=(0,h.Kp)((performance.now()-e)/1e3);this._updateAverageLoadingTime(r)})())),this.requireLoad=!1}_updateAverageLoadingTime(e){const t=T.S$;this._averageLoadingTime=(0,h.Kp)(t*e+(1-t)*this._averageLoadingTime)}triggerLoad(){this._debugAllowAutoLoading&&(this.requireLoad=!0)}async _load(e){const{extent:t,view:i}=this;if(!this._visible)return this.clear(),void(this._loadingState="ready-to-load");if(null==t)return void(this._loadingState="ready-to-load");const r=new M.y6(t,this.layerView.timeExtent,this._tracingResolution,i.state.contentPixelRatio,e);null==this._abortController&&(this._abortController=new AbortController);const s=this._abortController,n=await this._loadStreamlines(r,s.signal);if((0,a.Te)(s.signal),this._visible&&null!=n){this._lastResources?.detach(),this._lastResources=this._resources,this._resources=n;const t=performance.now()/1e3,i=t>e?t:e;null!=this._lastResources&&(this._lastResources.endTime=i),this._resources.startTime=i,await n.attach(),this._loadingState=this._seamlessTransitionEnabled?"before-transition":"transitioning"}else this._loadingState="ready-to-load"}async _loadStreamlines(e,t){const i=await this.fetchDataAndGenerateStreamlines(e,t);if(null==i)return null;const{geometries:r,material:s}=await this._createGeometry(e,i);return this._draped?new W(e,i,s,r,this.layerView):new z(e,i,s,r,this.view)}async fetchDataAndGenerateStreamlines(e,t){return null}async _createGeometry(e,t){const i=new $.W(this._materialParameters,this.view.state.isGlobal),r=new Array,{elevationInfo:s,_draped:n,view:a}=this;return await this.frameTask.scheduleGenerator(function*(o){for(let l=0;l<t.length;++l)r.push(D(a,e,t[l],s,i,n)),o.madeProgress(),o.done&&(o=yield)}),{geometries:r,material:i}}_triggerTilesUpdate(){if(this._tilesUpdateIsWaiting)return;this._tilesUpdateIsWaiting=!0;this.updatingHandles.addPromise((0,a.QZ)((async()=>{await(0,o.C_)(()=>this.view.stationary),this._tilesUpdateIsWaiting=!1,await this._debouncedTileUpdate()})()))}_getTileFilterFunction(){const{_dataBounds:e,view:t,_featureTilesBounds:i}=this;if(this.loadAllTiles)return t=>t.leaf&&J(e,t.extent);const r=t=>t.rendered&&t.visible&&J(e,t.extent),{featureTiles:n}=t;if(!n)return r;const a=n.tiles.filter(e=>e.measures.visible);return e=>r(e)&&J(i,e.extent)&&a.some(t=>{let{lij:i}=t;return(0,s.aI)(i,e.lij)||(0,H.ZH)(i,e.lij)})}_nextStateForTransition(e){const{_resources:t}=this;if(null==this._flowRenderer||null==t||"ready-to-load"===this._loadingState||"loading"===this._loadingState)return this._loadingState;const i=t.startTime;return e<i?"before-transition":e<i+T.um?"transitioning":"ready-to-load"}get usedMemory(){return(this._lastResources?.usedMemory??0)+(this._resources?.usedMemory??0)}get test(){}};(0,r.Cg)([(0,d.MZ)()],Y.prototype,"type",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"renderedTiles",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_resources",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_lastResources",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"requireLoad",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_averageLoadingTime",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_loadingState",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"emissiveStrength",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_clippingArea",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_dataBounds",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_draped",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_ellipsoidRadius",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"extent",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"loadAllTiles",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"isDataGlobal",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_featureTilesBounds",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_flowRenderer",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_materialParameters",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_opacity",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_seamlessTransitionWaitingTime",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_seamlessTransitionEnabled",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_tracingResolution",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_visible",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_estimatedStreamlines",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_effectiveDensity",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"elevationInfo",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"needsMagnitude",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"spatialReferenceInfo",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"layer",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"loadingState",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"updating",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"visibleAtCurrentScale",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_overrideMaterialParameters",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_overrideSimulationSettings",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_overrideTransitionEnabled",void 0),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"_simulationSettings",null),(0,r.Cg)([(0,d.MZ)()],Y.prototype,"surface",null),Y=(0,r.Cg)([(0,c.$)("esri.views.3d.layers.FlowSubView3D")],Y);const Q=new _.A({mode:"on-the-ground"});function J(e,t){return null==e||null==t||(0,p.HY)(e,t)}}}]);
//# sourceMappingURL=31450.b36c364d.chunk.js.map