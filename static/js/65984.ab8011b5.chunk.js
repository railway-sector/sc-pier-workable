"use strict";(self.webpackChunksc_pier_workable=self.webpackChunksc_pier_workable||[]).push([[65984],{1734:(e,t,i)=>{i.d(t,{G:()=>x,a:()=>b,b:()=>w});var s=i(72745),a=i(9392),n=i(94192),r=i(83166),o=i(52063),l=i(37754),c=i(95756),u=i(84115),h=i(5517),d=i(21390),p=i(86955),f=i(53908),g=i(72790),v=i(23687),m=i(70571),_=i(31432),y=i(2687);class x extends _.Y{constructor(){super(...arguments),this.totalGaussians=-1,this.focalLength=-1,this.minSplatRadius=-1,this.minSplatOpacity=-1,this.tanFov=s.uY,this.cameraDelta=a.uY,this.cameraPos8k=a.uY}}function w(e){const t=new y.N5;t.varyings.add("vColor","vec4"),t.varyings.add("conicOpacity","vec4"),t.varyings.add("depth","float"),t.varyings.add("gaussianCenterScreenPos","vec2"),t.varyings.add("fragScreenPos","vec2"),t.outputs.add("fragColor","vec4",0),t.vertex.uniforms.add(new m.R("splatOrderTexture",e=>e.splatOrder),new m.R("splatAtlasTexture",e=>e.splatAtlas),new g.c("numSplats",e=>e.totalGaussians),new d.m("focalLength",e=>e.focalLength),new d.m("minSplatRadius",e=>e.minSplatRadius),new d.m("minSplatOpacity",e=>e.minSplatOpacity),new c.G("tanFov",e=>e.tanFov),new h.t("cameraDelta",e=>e.cameraDelta),new h.t("cameraPos8k",e=>e.cameraPos8k),new f.W("fullWidth",e=>{let{camera:t}=e;return t.viewport[2]}),new f.W("fullHeight",e=>{let{camera:t}=e;return t.viewport[3]}),new v.F("proj",e=>e.camera.projectionMatrix),new v.F("view",e=>e.camera.viewMatrix),new u.d("cameraPosition",e=>e.camera.eye)),t.vertex.include(o.e),t.vertex.include(l.J),t.vertex.include(r.T),t.include(n.Z,e),t.vertex.code.add(p.H`float ndcToPixel(float ndcCoord, float screenSize) {
return ((ndcCoord + 1.0) * screenSize - 1.0) * 0.5;
}`),t.vertex.main.add("\n    uint instanceID = uint(gl_InstanceID);\n\n    // Transform the instanceID into 2D coordinates\n    uint orderTextureWidth = uint(textureSize(splatOrderTexture, 0).x);\n    uint x = instanceID % orderTextureWidth;\n    uint y = instanceID / orderTextureWidth;\n\n    // Fetch the index of the remaining frontmost Gaussian\n    uint gaussianIndex = texelFetch(splatOrderTexture, ivec2(x, y), 0).r;\n\n    uint splatAtlasSize = uint(textureSize(splatAtlasTexture, 0).x);\n\n    // Fetch the packed Gaussian according to the index\n    uint gaussianIndexX = gaussianIndex % uint(splatAtlasSize);\n    uint gaussianIndexY = gaussianIndex / uint(splatAtlasSize);\n    uvec4 packedGaussian = texelFetch(splatAtlasTexture, ivec2(gaussianIndexX, gaussianIndexY), 0);\n\n    // Fetch the header associated with the packed Gaussian (contains tile origin and number of fractional bits)\n    uint pageNum = gaussianIndex / 1024u;\n    uint headerIndex = (pageNum + 1u) * 1024u - 1u;\n    uint headerIndexX = headerIndex % uint(splatAtlasSize);\n    uint headerIndexY = headerIndex / uint(splatAtlasSize);\n    uvec4 packedHeader = texelFetch(splatAtlasTexture, ivec2(headerIndexX, headerIndexY), 0);\n\n    // Unpack the Gaussian\n    vColor = unpackColor(packedGaussian);\n    // Ignore gaussians with very small contribution, with tolerance based on the quality profile\n    if(vColor.a < minSplatOpacity) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    vec3 scale = unpackScale(packedGaussian); \n    vec4 quaternion = unpackQuaternion(packedGaussian);\n    mat3 rotation = quaternionToRotationMatrix(quaternion);\n    vec3 tileOriginRelativePosition = unpackTileOriginRelativePosition(packedGaussian);\n\n    vec3 cameraRelativePosition = unpackCameraRelativeGaussianPosition(packedHeader, tileOriginRelativePosition, cameraPosition, cameraPos8k, cameraDelta);\n\n    vec4 viewPos = vec4(mat3(view) * cameraRelativePosition, 1);\n\n    if (viewPos.z > 1.0) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    forwardViewPosDepth(viewPos.xyz);\n\n    vec3 covarianceA;\n    vec3 covarianceB;\n    computeCovariance3D(rotation, scale.xyz, covarianceA, covarianceB);\n\n    float covariance3D[6] = float[6](covarianceA.x, covarianceA.y, covarianceA.z, covarianceB.x, covarianceB.y, covarianceB.z);\n\n    vec3 covariance2D = computeCovariance2D(viewPos.xyz, focalLength, tanFov, covariance3D, view);\n    \n    // Invert covariance (EWA algorithm)\n    float determinant = (covariance2D.x * covariance2D.z - covariance2D.y * covariance2D.y);\n    if (determinant == 0.) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n    float invDeterminant = 1. / determinant;\n    \n\n    vec4 projPos = proj * viewPos;\n    float invW = 1. / (projPos.w + 1e-7);\n    vec3 ndcPos = projPos.xyz * invW;\n\n    // Compute extent in screen space (by finding the eigenvalues of the 2D covariance matrix). \n    // Use the extent to compute the bounding rectangle of the Gaussian in screen space.\n    float mid = 0.5 * (covariance2D.x + covariance2D.z);\n    float lambda1 = mid + sqrt(max(0.1, mid * mid - determinant));\n    float lambda2 = mid - sqrt(max(0.1, mid * mid - determinant));\n    float radius = ceil(3. * sqrt(max(lambda1, lambda2)));\n    gaussianCenterScreenPos = vec2(ndcToPixel(ndcPos.x, float(fullWidth)), ndcToPixel(ndcPos.y, float(fullHeight)));\n\n    // Ignore gaussians with very small contribution, with tolerance based on the quality profile\n    if(minSplatRadius > 0.0) {\n      float effectiveSize = radius * vColor.a;\n      if(effectiveSize < minSplatRadius) {\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n        return;\n      }\n    }\n\n    // This maps vertex IDs 0, 1, 2, 3 to (-1,-1), (1,-1), (-1,1), (1,1)\n    vec2 corner = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) - 1.0;\n\n    // Vertex (corner) position in screen space\n    fragScreenPos = gaussianCenterScreenPos + radius * corner;\n\n    // We use a conic function to derive the opacity\n    vec3 conic = vec3(covariance2D.z, -covariance2D.y, covariance2D.x) * invDeterminant;\n    conicOpacity = vec4(conic, vColor.a);\n\n    depth = ndcPos.z;\n    \n    // Convert from screen-space to clip-space\n    vec2 clipPos = fragScreenPos / vec2(fullWidth, fullHeight) * 2. - 1.;\n\n    gl_Position = vec4(clipPos, depth, 1.0);\n\n  ");const i=e.depthPass;return t.fragment.main.add(`\n    discardByTerrainDepth();\n    vec2 offsetFromCenter = gaussianCenterScreenPos - fragScreenPos;\n\n    // Evaluate the 2D elliptical Gaussian exponent using the general conic form: Ax^2+2Bxy+Cy^2\n    float x = offsetFromCenter.x;\n    float y = offsetFromCenter.y;\n    float A = conicOpacity.x;\n    float B = conicOpacity.y;\n    float C = conicOpacity.z;\n    float opacityScale = conicOpacity.w;\n    float gaussianExponent = -0.5 * (A * x * x + 2.0 * B * x * y + C * y * y);\n\n    // A positive exponent indicates alpha > 1, this should not happen\n    if (gaussianExponent > 0.0) {\n      discard;\n    }\n\n    float gaussianFalloff = exp(gaussianExponent);\n    \n      // cap at 0.99 to avoid blending issues, such as seams between overlapping Gaussians\n    float alpha = min(.99f, opacityScale * gaussianFalloff);\n\n    // discard low alpha fragments since their contribution would not be visible\n    if (alpha < 1./255.) {\n        discard;\n    }\n\n    // We cannot write color and depth in the same pass, as they require different blend modes.\n    // Regular depth writing based on first hit is not precise enough due to the inherently \n    // transparent nature of Gaussian Splats (especially at the borders of the Splat).\n    // We thus use a blended depth that computes a non-linear average using \n    // the splat order and opacity with geometric decay.\n    // This means the depth is averaged based on the order and opacity of the Gaussians,\n    // with the frontmost Gaussians contributing the most.\n    ${(0,p.If)(i,"fragColor = vec4(depth, 0, 0, alpha);","fragColor = vec4(vColor.rgb * alpha, alpha);")}\n  `),t}const b=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatPassParameters:x,build:w},Symbol.toStringTag,{value:"Module"}))},23456:(e,t,i)=>{i.d(t,{_8:()=>v,dJ:()=>g,uB:()=>m});var s=i(15941),a=i(20664),n=i(9392),r=i(34111),o=i(76797),l=i(91605),c=i(13312),u=i(45308);function h(e,t){if(!Array.isArray(e)||e.length<t)return!1;for(const i of e)if("number"!=typeof i)return!1;return!0}const d=7645211,p={xmin:-180,ymin:-90,zmin:-450,xmax:180,ymax:90,zmax:8850},f=new Map([[5773,new l.A({heightModel:"gravity-related-height",heightUnit:"meters",vertCRS:"EGM96_Geoid"})],[3855,new l.A({heightModel:"gravity-related-height",heightUnit:"meters",vertCRS:"EGM2008_Geoid"})],[115700,new l.A({heightModel:"ellipsoidal",heightUnit:"meters",vertCRS:"WGS_1984"})],[115701,new l.A({heightModel:"ellipsoidal",heightUnit:"meters",vertCRS:"ETRS_1989"})],[6360,new l.A({heightModel:"gravity-related-height",heightUnit:"us-feet",vertCRS:"NAVD88_height_(ftUS)"})],[7837,new l.A({heightModel:"gravity-related-height",heightUnit:"meters",vertCRS:"DHHN2016_(height) "})]]);function g(e){if(!e)return null;const t=e.vcsWkid||e.latestVcsWkid;return t?f.get(t):null}function v(e){return!(!(e.extensions?.ESRI_crs?.wkid||e.extensions?.ESRI_crs?.latestWkid||e.extensions?.ESRI_crs?.wkt)||!e.root?.extensions?.ESRI_crs?.boundingVolume?.box&&!e.root?.extensions?.ESRI_crs?.boundingVolume?.sphere)}function m(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=new c.A({wkid:4326,vcsWkid:115700}),l=e.root?.boundingVolume,f=!1,g=e?.root?.transform;if(t&&(e.extensions?.ESRI_crs?.wkid||e.extensions?.ESRI_crs?.latestWkid||e.extensions?.ESRI_crs?.wkt)&&(e.root?.extensions?.ESRI_crs?.boundingVolume?.box||e.root?.extensions?.ESRI_crs?.boundingVolume?.sphere))i=new c.A(e.extensions?.ESRI_crs),l=e.root?.extensions?.ESRI_crs?.boundingVolume,g=e.root?.transform,f=!0;else if(!l)return new o.A(-180,-90,180,90,i);if(l.box){const e=l?.box;if(e[3]>d&&e[7]>d&&e[11]>d)return new o.A({...p,spatialReference:i})}const v=(0,n.vt)();if(!f&&l.region&&h(l.region,6)){const e=l.region,t=(0,s.KJ)(e[0]),a=(0,s.KJ)(e[1]),n=e[4],r=(0,s.KJ)(e[2]),c=(0,s.KJ)(e[3]),u=e[5];return new o.A({xmin:t,ymin:a,zmin:n,xmax:r,ymax:c,zmax:u,spatialReference:i})}if(l.sphere&&h(l.sphere,4)){const e=l.sphere,t=(0,n.fA)(e[0],e[1],e[2]),s=e[3]/Math.sqrt(3),d=(0,n.vt)();(0,a.e)(d,t,(0,n.fA)(s,s,s));const p=(0,n.vt)();if((0,a.g)(p,t,(0,n.fA)(s,s,s)),g&&h(g,16)){const e=g;(0,a.t)(v,d,e),(0,a.d)(d,v),(0,a.t)(v,p,e),(0,a.d)(p,v)}f||((0,u.projectBuffer)(d,r.Ro,0,d,c.A.WGS84,0),(0,u.projectBuffer)(p,r.Ro,0,p,c.A.WGS84,0));const m=(0,n.vt)(),_=(0,n.vt)();return(0,a.A)(m,d,p),(0,a.z)(_,d,p),new o.A({xmin:m[0],ymin:m[1],zmin:m[2],xmax:_[0],ymax:_[1],zmax:_[2],spatialReference:i})}if(l.box&&h(l.box,12)){const e=l.box,t=(0,n.fA)(e[0],e[1],e[2]),s=(0,n.fA)(e[3],e[4],e[5]),d=(0,n.fA)(e[6],e[7],e[8]),p=(0,n.fA)(e[9],e[10],e[11]),v=[];for(let i=0;i<8;++i)v.push((0,n.vt)());if((0,a.g)(v[0],t,s),(0,a.g)(v[0],v[0],d),(0,a.g)(v[0],v[0],p),(0,a.a)(v[1],t,s),(0,a.g)(v[1],v[1],d),(0,a.g)(v[1],v[1],p),(0,a.g)(v[2],t,s),(0,a.a)(v[2],v[2],d),(0,a.g)(v[2],v[2],p),(0,a.a)(v[3],t,s),(0,a.a)(v[3],v[3],d),(0,a.g)(v[3],v[3],p),(0,a.g)(v[4],t,s),(0,a.g)(v[4],v[4],d),(0,a.a)(v[4],v[4],p),(0,a.a)(v[5],t,s),(0,a.g)(v[5],v[5],d),(0,a.a)(v[5],v[5],p),(0,a.g)(v[6],t,s),(0,a.a)(v[6],v[6],d),(0,a.a)(v[6],v[6],p),(0,a.a)(v[7],t,s),(0,a.a)(v[7],v[7],d),(0,a.a)(v[7],v[7],p),g&&h(g,16)){const e=g;for(let t=0;t<8;++t)(0,a.t)(v[t],v[t],e)}const m=(0,n.fA)(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),_=(0,n.fA)(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let i=0;i<8;++i)f||(0,u.projectBuffer)(v[i],r.Ro,0,v[i],c.A.WGS84,0),(0,a.A)(_,_,v[i]),(0,a.z)(m,m,v[i]);return new o.A({xmin:_[0],ymin:_[1],zmin:_[2],xmax:m[0],ymax:m[1],zmax:m[2],spatialReference:i})}return new o.A(-180,-90,180,90,i)}},37754:(e,t,i)=>{i.d(t,{J:()=>a});var s=i(86955);function a(e){e.code.add(s.H`mat3 quaternionToRotationMatrix(vec4 q) {
float x2 = q.x + q.x;
float y2 = q.y + q.y;
float z2 = q.z + q.z;
float xx = x2 * q.x;
float yy = y2 * q.y;
float zz = z2 * q.z;
float xy = x2 * q.y;
float xz = x2 * q.z;
float yz = y2 * q.z;
float wx = x2 * q.w;
float wy = y2 * q.w;
float wz = z2 * q.w;
return mat3(
1.0 - (yy + zz), xy - wz, xz + wy,
xy + wz, 1.0 - (xx + zz), yz - wx,
xz - wy, yz + wx, 1.0 - (xx + yy)
);
}`)}},52063:(e,t,i)=>{i.d(t,{e:()=>a});var s=i(86955);function a(e){e.code.add(s.H`vec4 unpackColor(uvec4 packedGaussian) {
vec4 color;
color.r = float((packedGaussian.w >> 1u) & 0xfeu);
color.g = float((packedGaussian.w >> 9u) & 0xffu);
color.b = float((packedGaussian.w >> 16u) & 0xfeu);
color.a = float((packedGaussian.w >> 24u) & 0xffu);
return color / 255.0;
}`),e.code.add(s.H`vec3 unpackScale(uvec4 packedGaussian) {
uint sx = (packedGaussian.z >> 10u) & 0xffu;
uint sy = (packedGaussian.z >> 18u) & 0xffu;
uint szLow = (packedGaussian.z >> 26u) & 0x3fu;
uint szHigh = packedGaussian.a & 0x3u;
uint sz = szLow | (szHigh << 6u);
return exp(vec3(sx, sy, sz) / 16.0 - 10.0);
}`),e.code.add(s.H`const uint MASK_9_BITS = 0x1FFu;
const float SQRT_HALF = 0.7071067811865476;
const ivec3 COMPONENT_ORDER[4] = ivec3[4](
ivec3(3, 2, 1),
ivec3(3, 2, 0),
ivec3(3, 1, 0),
ivec3(2, 1, 0)
);
vec4 unpackQuaternion(uvec4 packedGaussian) {
uint packedRotation = packedGaussian.x;
uint largestComponent = packedRotation >> 30u;
vec4 quaternion = vec4(0.0);
float sumSquares = 0.0;
uint bitfield = packedRotation;
for (int j = 0; j < 3; ++j) {
int index = COMPONENT_ORDER[int(largestComponent)][j];
uint magnitude = bitfield & MASK_9_BITS;
uint signBit = (bitfield >> 9u) & 1u;
bitfield = bitfield >> 10u;
float value = SQRT_HALF * float(magnitude) / float(MASK_9_BITS);
quaternion[index] = signBit == 1u ? -value : value;
sumSquares += value * value;
}
quaternion[int(largestComponent)] = sqrt(1.0 - sumSquares);
return quaternion;
}`),e.code.add(s.H`vec3 unpackTileOriginRelativePosition(uvec4 packedGaussian) {
uint packedPositionLow = packedGaussian.y;
uint packedPositionHigh = packedGaussian.z;
uint x = packedPositionLow & 0x3FFFu;
uint y = (packedPositionLow >> 14u) & 0x3FFFu;
uint zLow = (packedPositionLow >> 28u) & 0xFu;
uint zHigh = packedPositionHigh & 0x3FFu;
uint z = zLow | (zHigh << 4u);
return vec3(float(x), float(y), float(z));
}`),e.code.add(s.H`vec3 unpackCameraRelativeGaussianPosition(uvec4 packedHeader, highp vec3 position, vec3 cameraPosition, vec3 cameraPos8k, vec3 cameraDelta) {
vec3 tileOrigin = uintBitsToFloat(packedHeader.xyz);
float invPosScale = 1.0 / exp2(float(packedHeader.w & 0xffu));
vec3 delta = tileOrigin.xyz - cameraPos8k;
vec3 cameraRelativePosition = position.xyz * invPosScale + delta * 2.048 - cameraDelta;
return cameraRelativePosition;
}`)}},65984:(e,t,i)=>{i.r(t),i.d(t,{default:()=>_e});var s=i(6326),a=i(76460),n=i(30726),r=i(68134),o=i(31633),l=i(46053),c=(i(81806),i(47249),i(87990)),u=i(4336),h=i(47700),d=i(80963),p=i(23456),f=i(12482),g=i(81478),v=i(65768);class m extends v.P{constructor(e,t,i,s){super(e,0,0,0,t),this.cachedNodes=i,this.memoryMBCached=s}}var _=i(83491),y=i(75228),x=i(59231);const w=4096,b=1023,S=1024;class C{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:64;this._pageCount=e;const t=Math.ceil(e/32);this._bitset=new Uint32Array(t)}get pageCount(){return this._pageCount}isAllocated(e){const t=e/32|0,i=e%32;return!!(this._bitset[t]&1<<i)}allocate(e){const t=e/32|0,i=e%32;this._bitset[t]|=1<<i}free(e){const t=e/32|0,i=e%32;this._bitset[t]&=~(1<<i)}findFirstFreePage(){for(let e=0;e<this._bitset.length;e++)if(4294967295!==this._bitset[e])for(let t=0;t<32;t++){const i=32*e+t;if(i>=this._pageCount)break;if(!(this._bitset[e]&1<<t))return i}return null}resize(e){this._pageCount=e;const t=Math.ceil(e/32),i=this._bitset.length;if(t!==i){const e=new Uint32Array(t),s=Math.min(i,t);e.set(this._bitset.subarray(0,s)),this._bitset=e}this._clearExcessBits(this._bitset,e)}_clearExcessBits(e,t){const i=Math.floor((t-1)/32),s=(t-1)%32;if(t>0&&s<31){const t=(1<<s+1)-1;e[i]&=t}i+1<e.length&&e.fill(0,i+1)}}var P=i(97255);class A{constructor(e,t,i,s,a,n,r){this.handle=e,this.obb=t,this.gaussianAtlasIndices=i,this.pageIds=s,this.positions=a,this.squaredScales=n,this.maxScale=r,this.isVisible=!1,this.usedMemory=(0,P.Qf)(this.gaussianAtlasIndices,this.positions,this.squaredScales)+4096*this.pageIds.length*4}}i(50076);var T=i(19555),M=i(72745),D=i(20664),R=i(9392),z=i(43047),I=i(13927),k=i(95925),G=i(78315),E=i(90364),q=i(45270),O=i(18690),H=i(75540),F=i(1873),U=i(12016);class V extends U.B{constructor(e){super("GaussianSplatSortWorker","sort",{sort:e=>[e.distances.buffer,e.sortOrderIndices.buffer]},e,{strategy:"dedicated"})}sort(e,t){return this.invokeMethod("sort",e,t)}async destroyWorkerAndSelf(){await this.broadcast({},"destroy"),this.destroy()}}i(76718);var B=i(12331),L=(i(44488),i(62881),i(29492)),N=i(93345),W=(i(61678),i(96673));class Z{constructor(e){this.texture=null,this._orderTextureCapacity=0,this._rctx=e}ensureCapacity(e){if(this._orderTextureCapacity<e){this.texture?.dispose();const t=Math.ceil(e*O.Ji),i=this._evalTextureSize(t),s=i[0]*i[1];this._orderBuffer=new Uint32Array(s);const a=new W.R;a.height=i[0],a.width=i[1],a.pixelFormat=36244,a.dataType=N.ld.UNSIGNED_INT,a.internalFormat=N.H0.R32UI,a.wrapMode=33071,a.samplingMode=9728,this.texture=new L.g(this._rctx,a),this._orderTextureCapacity=s}}setData(e,t){this.ensureCapacity(t),this._orderBuffer?.set(e),this.texture?.setData(this._orderBuffer)}clear(){this._orderTextureCapacity=0,this.texture?.dispose(),this.texture=null}destroy(){this.texture?.dispose()}_evalTextureSize(e){const t=Math.ceil(Math.sqrt(e)),i=Math.ceil(e/t);return(0,M.fA)(t,i)}}class j{constructor(e,t,i){this._splatAtlasTextureHeight=16,this.texture=null,this._rctx=e,this._fboCache=i,this.pageAllocator=new C,this._cache=t.newCache("gaussian texture cache",e=>e.dispose())}ensureTextureAtlas(){if(this.texture)return;const e=this._cache.pop("splatTextureAtlas");if(e)return void(this.texture=e);const t=new W.R;t.height=this._splatAtlasTextureHeight,t.width=w,t.pixelFormat=36249,t.dataType=N.ld.UNSIGNED_INT,t.internalFormat=N.H0.RGBA32UI,t.samplingMode=9728,t.wrapMode=33071,this.texture=new L.g(this._rctx,t),this._updatePageAllocator()}grow(){if(!this.texture)return this.ensureTextureAtlas(),!1;const e=Math.floor(this._splatAtlasTextureHeight*O.Ji);if(e*w>this._rctx.parameters.maxPreferredTexturePixels)return!1;const t=new B.H(this._rctx,this.texture),i=this._fboCache.acquire(w,e,"gaussian splat atlas resize",11);return this._rctx.blitFramebuffer(t,i.fbo,16384,9728,0,0,w,this._splatAtlasTextureHeight,0,0,w,this._splatAtlasTextureHeight),this.texture?.dispose(),this.texture=i.fbo?.detachColorTexture(),t.dispose(),i.dispose(),this._splatAtlasTextureHeight=e,this._updatePageAllocator(),!0}requestPage(){let e=this.pageAllocator.findFirstFreePage();return null===e&&this.grow()&&(e=this.pageAllocator.findFirstFreePage()),null!==e&&this.pageAllocator.allocate(e),e}freePage(e){this.pageAllocator.free(e)}update(e,t,i){this.ensureTextureAtlas(),this.texture.updateData(0,e,t,S,1,i)}_updatePageAllocator(){const e=w*this._splatAtlasTextureHeight/S;this.pageAllocator.pageCount!==e&&this.pageAllocator.resize(e)}clear(){this.texture&&(this._cache.put("splatTextureAtlas",this.texture),this.texture=null)}destroy(){this._cache.destroy(),this.texture?.dispose()}}class ${constructor(e){this._updating=(0,H.v)(!1),this.visibleGaussians=0,this._visibleGaussianTiles=new Array,this._workerHandle=null,this._isSorting=!1,this._pendingSortTask=!1,this._bufferCapacity=0,this._renderer=e,this._orderTexture=new Z(this._renderer.renderingContext),this._textureAtlas=new j(this._renderer.renderingContext,this._renderer.view.resourceController.memoryController,this._renderer.fboCache);const{resourceController:t}=this._renderer.view;this._workerHandle=new V((0,F.m)(t))}get textureAtlas(){return this._textureAtlas}get orderTexture(){return this._orderTexture}get visibleGaussianTiles(){return this._visibleGaussianTiles}updateGaussianVisibility(e){this._visibleGaussianTiles=e,this.requestSort()}isUpdating(){return this._updating.value}destroy(){this._pendingSortTask=!1,this._workerHandle?.destroyWorkerAndSelf(),this._textureAtlas.destroy(),this._orderTexture.destroy()}requestSort(){this._updating.value=!0,this._isSorting?this._pendingSortTask=!0:(this._isSorting=!0,this._pendingSortTask=!1,this._sortOnWorker().then(()=>this._handleSortComplete()).catch(()=>this._handleSortComplete()))}_handleSortComplete(){this._isSorting=!1,this._pendingSortTask?this.requestSort():this._updating.value=!1}_clearBuffersAndTextures(){this._bufferCapacity=0,this._orderTexture.clear(),this._textureAtlas.clear()}_ensureBufferCapacity(e){if(this._bufferCapacity<e){const t=Math.ceil(e*O.Ji);this._atlasIndicesBuffer=new Uint32Array(t),this._sortedAtlasIndicesBuffer=new Uint32Array(t),this._distancesBuffer=new Float64Array(t),this._sortOrderBuffer=new Uint32Array(t),this._bufferCapacity=t}}async _sortOnWorker(){let e=0;if(this._visibleGaussianTiles.forEach(t=>e+=t.gaussianAtlasIndices.length),0===e)return this.visibleGaussians=0,this._clearBuffersAndTextures(),void this._renderer.requestRender(1);this._ensureBufferCapacity(e),this._textureAtlas.ensureTextureAtlas();const t=this._renderer.camera.eye,i=t[0],s=t[1],a=t[2],n=this._atlasIndicesBuffer.subarray(0,e);let r=0;this._visibleGaussianTiles.forEach(e=>{const t=e.gaussianAtlasIndices,o=e.positions;for(let l=0;l<t.length;l++){n[r]=t[l];const e=3*l,c=o[e],u=o[e+1],h=o[e+2],d=c-i,p=u-s,f=h-a;this._distancesBuffer[r]=d*d+p*p+f*f,r++}});for(let l=0;l<e;l++)this._sortOrderBuffer[l]=l;const o={distances:this._distancesBuffer,sortOrderIndices:this._sortOrderBuffer,numGaussians:e,preciseSort:!1};await(this._workerHandle?.sort(o).then(t=>{this._distancesBuffer=t.distances,this._sortOrderBuffer=t.sortedOrderIndices;const i=this._sortedAtlasIndicesBuffer.subarray(0,e);for(let a=0;a<e;a++)i[a]=n[t.sortedOrderIndices[a]];this._orderTexture.setData(i,e);const s=this._renderer.view.qualitySettings.gaussianSplat.maxAllowedVisibleGaussians;this.visibleGaussians=Math.min(e,s),this._renderer.requestRender(1)}))}}var J=i(36451),Y=i(82805),X=i(1734),K=i(87986),Q=i(16506),ee=i(59246),te=i(11850),ie=i(57162);class se extends ee.w{constructor(e,t){super(e,t,new Q.$(K.S,()=>i.e(48392).then(i.bind(i,48392))),te.Nx)}initializePipeline(){return(0,ie.Ey)({colorWrite:ie.kn,depthTest:null,depthWrite:ie.Uy})}}var ae=i(95745);class ne extends ee.w{constructor(e,t){super(e,t,new Q.$(ae.S,()=>i.e(16691).then(i.bind(i,16691))),te.Nx)}initializePipeline(){return(0,ie.Ey)({colorWrite:null,depthTest:{func:515},depthWrite:ie.Uy,drawBuffers:{buffers:[N.$0]}})}}class re extends ee.w{constructor(e,t){super(e,t,new Q.$(X.a,()=>i.e(82416).then(i.bind(i,82416))),te.Nx)}_createPipeline(){return(0,ie.Ey)({blending:(0,ie.p3)(773,773,772,1,32774,32774),depthTest:{func:513},colorWrite:ie.kn})}initializePipeline(){return this._createPipeline()}}class oe extends ee.w{constructor(e,t){super(e,t,new Q.$(X.a,()=>i.e(82416).then(i.bind(i,82416))),te.Nx)}_createPipeline(){return(0,ie.Ey)({blending:(0,ie.p3)(773,773,1,1,32774,32774),depthTest:{func:515},colorWrite:ie.kn})}initializePipeline(){return this._createPipeline()}}var le,ce=i(6485);class ue extends ce.K{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];super(),this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.depthPass=e}}(0,s.Cg)([(0,ce.W)()],ue.prototype,"terrainDepthTest",void 0),(0,s.Cg)([(0,ce.W)()],ue.prototype,"cullAboveTerrain",void 0);let he=class extends J.A{constructor(){super(...arguments),this.gaussianPosition=(0,R.vt)(),this.intersectionRayDir=(0,R.vt)(),this.intersectionPlane=(0,I.vt)(),this._slicePlaneEnabled=!1,this._data=null,this.produces=E.hM.OPAQUE,this.type=0,this.isGround=!1,this.layerViewUid="",this._gaussianSplatParameters=new X.G,this._gaussianSplatCompositionParameters=new K.G,this._gaussianSplatDepthCompositionParameters=new ae.G,this._splatTechniqueConfiguration=new ue,this._splatDepthTechniqueConfiguration=new ue(!0),this._previousCameraPosition=(0,R.vt)(),this._previousCameraDirection=(0,R.vt)(),this._tanFov=(0,M.vt)(),this._tempVec=(0,R.vt)(),this._cameraDelta=(0,R.vt)(),this._coarseCameraPosition=(0,R.vt)()}static#e=(()=>le=this)();async initialize(){this._data=new $(this),this.view.sceneIntersectionHelper.addIntersectionHandler(this),this.addHandles([(0,r.wB)(()=>this.view.state.camera,()=>this._onCameraChange())])}precompile(){this._splatTechniqueConfiguration.terrainDepthTest=this.bindParameters.terrainDepthTest,this.techniques.precompile(oe,this._splatTechniqueConfiguration),this._splatDepthTechniqueConfiguration.terrainDepthTest=this.bindParameters.terrainDepthTest,this.techniques.precompile(re,this._splatDepthTechniqueConfiguration),this.techniques.precompile(se),this.techniques.precompile(ne)}render(e){const t=e.find(e=>{let{name:t}=e;return t===E.hM.OPAQUE});if(!this._data.visibleGaussians||!this._data.orderTexture.texture||!this._data.textureAtlas.texture)return t;const i=this.techniques.get(oe,this._splatTechniqueConfiguration),s=this.techniques.get(re,this._splatDepthTechniqueConfiguration),a=this.techniques.get(se),n=this.techniques.get(ne);if(!(i.compiled&&s.compiled&&n.compiled&&a.compiled))return this.requestRender(1),t;const{fullWidth:r,fullHeight:o}=this.bindParameters.camera,l=this.fboCache,c=l.acquire(r,o,"gaussian color output");c.attachDepth(t.getAttachment(N.nI));const u=this.renderingContext;u.bindFramebuffer(c.fbo),u.setClearColor(0,0,0,0),u.clear(16384),this._gaussianSplatParameters.totalGaussians=this._data.visibleGaussians,this._gaussianSplatParameters.splatOrder=this._data.orderTexture.texture,this._gaussianSplatParameters.splatAtlas=this._data.textureAtlas.texture;const h=Math.tan(.5*this.camera.fovY),d=h/o*r;(0,T.hZ)(this._tanFov,d,h);const p=o/(2*h);this._gaussianSplatParameters.focalLength=p,this._gaussianSplatParameters.tanFov=this._tanFov;const f=this.view.qualitySettings.gaussianSplat,g=f.minimumSplatPixelRadius*Math.sqrt(r*o)/Math.sqrt(2073600);this._gaussianSplatParameters.minSplatRadius=g,this._gaussianSplatParameters.minSplatOpacity=f.minimumOpacity,this._prepareHighPrecisionCameraPosition(),this.renderingContext.bindTechnique(i,this.bindParameters,this._gaussianSplatParameters),this.renderingContext.drawArraysInstanced(N.WR.TRIANGLE_STRIP,0,4,this._data.visibleGaussians);const v=l.acquire(r,o,"splat depth",8);v.attachDepth(t.getAttachment(N.nI)),u.bindFramebuffer(v.fbo),u.setClearColor(0,0,0,0),u.clear(16384),this.renderingContext.bindTechnique(s,this.bindParameters,this._gaussianSplatParameters),this.renderingContext.drawArraysInstanced(N.WR.TRIANGLE_STRIP,0,4,this._data.visibleGaussians);const m=l.acquire(r,o,this.produces);return this._gaussianSplatDepthCompositionParameters.splatDepth=v.getTexture(),m.attachDepth(t.getAttachment(N.nI)),u.bindFramebuffer(m.fbo),u.bindTechnique(n,this.bindParameters,this._gaussianSplatDepthCompositionParameters),u.screen.draw(),this._gaussianSplatCompositionParameters.color=t.getTexture(),this._gaussianSplatCompositionParameters.splatColor=c.getTexture(),u.bindFramebuffer(m.fbo),u.bindTechnique(a,this.bindParameters,this._gaussianSplatCompositionParameters),u.screen.draw(),c.release(),v.release(),m}intersect(e,t,i,s){const{gaussianPosition:a,intersectionRayDir:n,intersectionPlane:r,layerViewUid:o}=this,l=(0,k.Cr)(i,s);(0,D.e)(n,s,i);const c=1/(0,D.b)(n);(0,D.h)(n,n,c);const u=(0,R.vt)();(0,D.u)(u,n),(0,z.s)(r,n[0],n[1],n[2],-(0,D.f)(n,i));const h=new pe,d=new pe,p=new Array;this._data.visibleGaussianTiles.forEach(f=>{const{maxScale:g}=f,v=f.obb.minimumDistancePlane(r),m=f.obb.maximumDistancePlane(r),_=m<0,y=null!=h.dist&&null!=d.dist&&h.dist<v*c&&d.dist>m*c;if(_||y)return;const x=(0,G.j)(f.obb.center,f.obb.radius+g);if(!(0,G.i)(x,l,null))return;if(!f.obb.intersectRay(i,n,g))return;const{positions:w,squaredScales:b,gaussianAtlasIndices:S}=f,C=S.length;for(let r=0;r<C;r++){const l=3*r;a[0]=w[l]-i[0],a[1]=w[l+1]-i[1],a[2]=w[l+2]-i[2];const f=b[r],g=(0,D.f)(a,n),v=g*g;if((0,D.m)(a)-v>f)continue;const m=g*c,_=e=>(e.point=e.point?e.point.fill(a[0],a[1],a[2]):(0,R.o8)(a),e.dist=m,e.normal=u,e.layerViewUid=o,e);if((null==h.dist||m<h.dist)&&(null==t||t(i,s,m))&&_(h),0!==e.options.store&&(null==d.dist||m>d.dist)&&(null==t||t(i,s,m))&&_(d),2===e.options.store&&(null==t||t(i,s,m))){const e=new pe;p.push(_(e))}}});const f=(e,t)=>{const{layerViewUid:i}=t,s=new q.bo(t.point,i);e.set(0,s,t.dist,t.normal)};if(de(h)){const t=e.results.min;(null==t.distance||h.dist<t.distance)&&f(t,h)}if(de(d)&&0!==e.options.store){const t=e.results.max;(null==t.distance||d.dist>t.distance)&&f(t,d)}if(2===e.options.store)for(const g of p){const t=new Y.i(l);f(t,g),e.results.all.push(t)}}get slicePlaneEnabled(){return this._slicePlaneEnabled}set slicePlaneEnabled(e){this._slicePlaneEnabled!==e&&(this._slicePlaneEnabled=e,this.requestRender(1))}get data(){return this._data}destroy(){this._data.destroy(),super.destroy()}_onCameraChange(){const e=this.view.state.camera.eye,t=this.view.state.camera.ray.direction,i=.001;(Math.abs(e[0]-this._previousCameraPosition[0])>i||Math.abs(e[1]-this._previousCameraPosition[1])>i||Math.abs(e[2]-this._previousCameraPosition[2])>i||Math.abs(t[0]-this._previousCameraDirection[0])>i||Math.abs(t[1]-this._previousCameraDirection[1])>i||Math.abs(t[2]-this._previousCameraDirection[2])>i)&&this._data.requestSort()}_prepareHighPrecisionCameraPosition(){(0,D.h)(this._tempVec,this.camera.eye,1/le.tileSize),(0,D.J)(this._tempVec,this._tempVec),(0,D.d)(this._coarseCameraPosition,this._tempVec),this._gaussianSplatParameters.cameraPos8k=this._coarseCameraPosition,(0,D.h)(this._tempVec,this._tempVec,le.tileSize),(0,D.e)(this._cameraDelta,this.camera.eye,this._tempVec),this._gaussianSplatParameters.cameraDelta=this._cameraDelta}static#t=(()=>this.tileSize=2.048)()};function de(e){return null!=e.dist&&null!=e.point}he=le=(0,s.Cg)([(0,c.$)("esri.views.3d.webgl-engine.lib.GaussianSplatRenderNode")],he);class pe{constructor(){this.point=null,this.dist=null,this.normal=null,this.layerViewUid=""}}var fe=i(91196),ge=i(90992);const ve=()=>a.A.getLogger("esri.views.3d.layers.GaussianSPlatLayerView3D");let me=class extends((0,_.w)(fe.A)){constructor(e){super(e),this.type="gaussian-splat-3d",this._gaussianTileHandles=new Map,this._pageBuffer=new Uint32Array(4096),this._wasmLayerId=-1,this._metersPerVCSUnit=1,this.ignoresMemoryFactor=!1,this._usedMemory=0,this._cacheMemory=0,this._useEsriCrs=!1,this.fullExtentInLocalViewSpatialReference=null,this._suspendedHandle=null,this._conversionBuffer=new ArrayBuffer(4),this._u32View=new Uint32Array(this._conversionBuffer),this._f32View=new Float32Array(this._conversionBuffer);const{view:t}=e;this._memCache=t.resourceController.memoryController.newCache(`GaussianSplat-${this.uid}`,e=>this._deleteTile(e)),this._renderNode=new he({view:t})}initialize(){if(!this._canProjectWithoutEngine())throw(0,ge.lQ)("layer",this.layer.spatialReference.wkid,this.view.renderSpatialReference?.wkid);const e=(0,y.Bk)(this).then(e=>{this._wasmLayerId=e,this.addHandles([(0,r.wB)(()=>this.layer.elevationInfo,e=>this._elevationInfoChanged(e))]),this._suspendedHandle=(0,r.wB)(()=>this.suspended,e=>this._wasm?.setEnabled(this,!e),r.pc)});this.addResolvingPromise(e)}get wasmLayerId(){return this._wasmLayerId}get metersPerVCSUnit(){return this._metersPerVCSUnit}isUpdating(){const e=this._wasm;return!(this._wasmLayerId<0||null==e)&&(e.isUpdating(this._wasmLayerId)||this._renderNode.data.isUpdating())}updatingFlagChanged(){this.notifyChange("updating")}get _wasm(){return(0,y.pw)(this.view)}get usedMemory(){return this._usedMemory}get unloadedMemory(){return 0}get cachedMemory(){return this._cacheMemory}get useEsriCrs(){return this._useEsriCrs}async createRenderable(e){const t=e.meshData;if(null==t.data)throw new Error("meshData.data undefined");if(t.desc=JSON.parse(t.desc),null==t.desc)throw new Error("meshData.desc undefined");const i=t.desc.prims[0],s=i.vertexCount,a=i.atrbs[0].view,n=i.atrbs[0].view.byteCount,r=i.atrbs[0].view.byteOffset;let o=null;if("U32"!==a.type)return ve().warnOnce("unexpected meshData.data format"),{memUsageBytes:0};o=new Uint32Array(t.data.buffer,r,n/4);const l=this.extractHeader(o),c=Math.ceil(s/b),h=new Uint32Array(s),d=[];for(let u=0;u<c;u++){let e=this._data.textureAtlas.requestPage();if(null===e&&(this._freeInvisibleTiles(),e=this._data.textureAtlas.requestPage()),null===e)return ve().warnOnce("ran out of gaussian splat memory"),{memUsageBytes:0};{d.push(e);const t=s-u*b,i=Math.min(t,b),a=u*b;for(let s=0;s<i;s++)h[s+a]=s+S*e;const n=4092*u;this._pageBuffer.set(o.subarray(n,n+4*i)),this._pageBuffer.set(l.packedHeader,4092);const r=e*S,c=r%w,p=Math.floor(r/w);this._data.textureAtlas.update(c,p,this._pageBuffer)}}const p=new Float64Array(3*s),f=new Float64Array(s),g=2.048,v=l.tileOrigin.x*g,m=l.tileOrigin.y*g,_=l.tileOrigin.z*g,y=l.invPosScale;let C=0,P=0;for(let u=0;u<s;u++){const e=4*u,{rawX:t,rawY:i,rawZ:s}=this._extractGaussianPosition(o,e),a=this._extractGaussianSphericalScale(o,e);p[C]=t*y+v,p[C+1]=i*y+m,p[C+2]=s*y+_,f[u]=a*a,P=Math.max(P,a),C+=3}let T=null;if(t.desc.obb){const e=t.desc.obb.quaternion;T=new x.ab(t.desc.obb.center,t.desc.obb.halfSize,(0,u.fA)(...e))}T||(ve().warnOnce("encountered tile without a bounding box"),T=new x.ab);const M=new A(e.handle,T,h,d,p,f,P);return this._memCache.put(`${M.handle}`,M),this._gaussianTileHandles.set(e.handle,M),this._cacheMemory+=M.usedMemory,{memUsageBytes:M.usedMemory}}_extractGaussianPosition(e,t){const i=e[t+1];return{rawX:16383&i,rawY:i>>>14&16383,rawZ:i>>>28&15|(1023&e[t+2])<<4}}_extractGaussianSphericalScale(e,t){const i=e[t+2],s=i>>>10&255,a=i>>>18&255,n=i>>>26&63|(3&e[t+3])<<6,r=Math.exp(s/16-10),o=Math.exp(a/16-10),l=Math.exp(n/16-10);return Math.max(r,o,l)}freeRenderable(e){const t=this._gaussianTileHandles.get(e);t&&(t.isVisible?this._usedMemory-=t.usedMemory:this._cacheMemory-=t.usedMemory,t.pageIds.forEach(e=>this._data.textureAtlas.freePage(e)),this.freeObject(t),this._gaussianTileHandles.delete(e)),this._updateGaussians()}freeObject(e){this._memCache.pop(`${e.handle}`)}get visibleAtCurrentScale(){return(0,ge.E5)(this.layer.effectiveScaleRange,this.view.scale)}setRenderableVisibility(e,t,i){for(let s=0;s<i;s++){if(!t[s])continue;const i=e[s],a=this._gaussianTileHandles.get(i);if(a){if(a.isVisible)continue;a.isVisible=!0,this._usedMemory+=a.usedMemory,this._cacheMemory-=a.usedMemory,this._memCache.pop(`${i}`)}}for(let s=0;s<i;s++){if(t[s])continue;const i=e[s],a=this._gaussianTileHandles.get(i);if(a){if(!a.isVisible)continue;a.isVisible=!1,this._usedMemory-=a.usedMemory,this._cacheMemory+=a.usedMemory,this._memCache.put(`${i}`,a)}}this._updateGaussians()}destroy(){(0,y.r8)(this),this._suspendedHandle&&(this._suspendedHandle=(0,n.xt)(this._suspendedHandle)),this._renderNode.destroy(),this._memCache.destroy()}_canProjectWithoutEngine(){if(1===this.view.state.viewingMode)return!0;if((0,d.r1)(this.view.renderSpatialReference)||(0,d.K8)(this.view.renderSpatialReference))return!0;if(this.layer.esriCrsSpatialReference&&(0,d.aI)(this.layer.esriCrsSpatialReference,this.view.renderSpatialReference)){const e=(0,p.dJ)(this.layer.esriCrsSpatialReference),t=this.view.heightModelInfo;return this._useEsriCrs=0===(0,h.$U)(e,t,!1),this._useEsriCrs&&e&&(this._metersPerVCSUnit=(0,o.oU)(1,"meters",e.heightUnit),this.fullExtentInLocalViewSpatialReference=this.layer.esriCrsFullExtent),this._useEsriCrs}return!1}_elevationInfoChanged(e){if(e?.offset)if(this._useEsriCrs){const t=(0,g.Ao)(e?.unit)/this._metersPerVCSUnit,i=e?.offset??0;this._wasm?.setLayerOffset(this,i*t)}else this._wasm?.setLayerOffset(this,(0,f.M7)(e));else this._wasm?.setLayerOffset(this,0)}_updateGaussians(){const e=new Array;for(const t of this._gaussianTileHandles.values())t.isVisible&&e.push(t);this._data.updateGaussianVisibility(e),this.notifyChange("updating")}_freeInvisibleTiles(){for(const e of this._gaussianTileHandles.values())e.isVisible||this._deleteTile(e)}get _data(){return this._renderNode.data}extractHeader(e){const t=e.length-4,i=this.reinterpretU32AsFloat(e[t]),s=this.reinterpretU32AsFloat(e[t+1]),a=this.reinterpretU32AsFloat(e[t+2]),n=1/(1<<(255&e[t+3]));return{packedHeader:e.subarray(t,t+4),tileOrigin:{x:i,y:s,z:a},invPosScale:n}}_deleteTile(e){this._wasm?.onRenderableEvicted(this,e.handle,e.usedMemory),this.freeRenderable(e.handle)}reinterpretU32AsFloat(e){return this._u32View[0]=e,this._f32View[0]}get performanceInfo(){let e=0,t=0;return this._gaussianTileHandles.forEach(i=>{i.isVisible?e++:t++}),new m(this.usedMemory,e,t,this.cachedMemory)}};(0,s.Cg)([(0,l.MZ)()],me.prototype,"layer",void 0),(0,s.Cg)([(0,l.MZ)()],me.prototype,"fullExtentInLocalViewSpatialReference",void 0),(0,s.Cg)([(0,l.MZ)({readOnly:!0})],me.prototype,"visibleAtCurrentScale",null),me=(0,s.Cg)([(0,c.$)("esri.views.3d.layers.GaussianSplatLayerView3D")],me);const _e=me},83166:(e,t,i)=>{i.d(t,{T:()=>a});var s=i(86955);function a(e){e.code.add(s.H`void computeCovariance3D(in mat3 rotation, in vec3 scale, out vec3 covarianceA, out vec3 covarianceB) {
mat3 scaleMatrix = mat3(
vec3(scale.x, 0.0, 0.0),
vec3(0.0, scale.y, 0.0),
vec3(0.0, 0.0, scale.z)
);
mat3 M = scaleMatrix * rotation;
mat3 covariance3D = transpose(M) * M;
covarianceA = vec3(covariance3D[0][0], covariance3D[0][1], covariance3D[0][2]);
covarianceB = vec3(covariance3D[1][1], covariance3D[1][2], covariance3D[2][2]);
}
vec3 computeCovariance2D(vec3 center, float focalLength, vec2 tanFov, float[6] cov3D, mat4 view) {
vec4 viewSpacePoint = vec4(center, 1);
vec2 max = 1.3 * tanFov;
vec2 normalized = viewSpacePoint.xy / viewSpacePoint.z;
viewSpacePoint.xy = clamp(normalized, -max, max) * viewSpacePoint.z;
float invZ = 1.0 / viewSpacePoint.z;
float invZSquared = invZ * invZ;
mat3 projectionJacobian = mat3(
focalLength * invZ,  0.0,                   -(focalLength * viewSpacePoint.x) * invZSquared,
0.0,                 focalLength * invZ,    -(focalLength * viewSpacePoint.y) * invZSquared,
0.0,                 0.0,                   0.0
);
mat3 worldToView = transpose(mat3(view));
mat3 T = worldToView * projectionJacobian;
mat3 covariance3D = mat3(
cov3D[0], cov3D[1], cov3D[2],
cov3D[1], cov3D[3], cov3D[4],
cov3D[2], cov3D[4], cov3D[5]
);
mat3 covariance2D = transpose(T) * transpose(covariance3D) * T;
const float regularization = 0.3;
covariance2D[0][0] += regularization;
covariance2D[1][1] += regularization;
return vec3(covariance2D[0][0], covariance2D[0][1], covariance2D[1][1]);
}`)}},83491:(e,t,i)=>{i.d(t,{w:()=>u});var s=i(6326),a=i(54901),n=i(50346),r=i(68134),o=i(46053),l=(i(81806),i(76460),i(47249),i(87990)),c=i(47700);const u=e=>{const t=e;let i=class extends t{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(){super.postscript(),(0,c.jI)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}async _validateHeightModelInfo(){const e=new AbortController,t=e.signal;this.addHandles((0,a.hA)(()=>e.abort())),await(0,r.C_)(()=>this.view.defaultsFromMap?.heightModelInfoReady,t),(0,n.Te)(t);const i=(0,c.Hu)(this.layer,this.view.heightModelInfo,this.supportsHeightUnitConversion);if(i)throw i}};return(0,s.Cg)([(0,o.MZ)()],i.prototype,"view",void 0),(0,s.Cg)([(0,o.MZ)()],i.prototype,"slicePlaneEnabled",void 0),i=(0,s.Cg)([(0,l.$)("esri.views.3d.layers.LayerView3D")],i),i}},87986:(e,t,i)=>{i.d(t,{G:()=>l,S:()=>u,b:()=>c});var s=i(73398),a=i(86955),n=i(70367),r=i(31432),o=i(2687);class l extends r.Y{}function c(){const e=new o.N5;return e.include(s.c),e.fragment.uniforms.add(new n.N("colorTexture",e=>e.color),new n.N("splatOutputColor",e=>e.splatColor)),e.fragment.main.add(a.H`vec4 color = texture(colorTexture, uv);
vec4 splatColor = texture(splatOutputColor, uv);
fragColor = splatColor + color * (1.0 - splatColor.a);`),e}const u=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatCompositionPassParameters:l,build:c},Symbol.toStringTag,{value:"Module"}))},91196:(e,t,i)=>{i.d(t,{A:()=>p});var s=i(6326),a=i(54099),n=i(5632),r=i(76460),o=i(30726),l=i(91291),c=i(46053),u=(i(81806),i(47249),i(87990)),h=i(19451),d=i(90992);let p=class extends((0,n.sA)((0,l.g)(a.nJ))){get spatialReferenceSupported(){return!0}constructor(e){super(e),this._updatingHandles=new h.U,this.layer=null,this.parent=null}initialize(){this.when().catch(e=>{if("layerview:create-error"!==e.name){const t=this.layer&&this.layer.id||"no id",i=this.layer?.title||"no title";r.A.getLogger(this).error("#resolve()",`Failed to resolve layer view (layer title: '${i}', id: '${t}')`,e)}})}destroy(){this._updatingHandles=(0,o.pR)(this._updatingHandles),this._set("parent",null)}get fullOpacity(){return(this.layer?.opacity??1)*(this.parent?.fullOpacity??1)}get suspended(){return this.destroyed||!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){return!this.suspended&&!0===this.layer?.legendEnabled}get updating(){return!(!this._updatingHandles?.updating&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get updateSuspended(){return this.suspended}get visible(){return!0===this.layer?.visible}set visible(e){this._overrideIfSome("visible",e)}get visibleAtCurrentScale(){return!0}get visibleAtCurrentTimeExtent(){const e=this.view.timeExtent,t=this.layer?.visibilityTimeExtent;return!e||!t||!e.intersection(t).isEmpty}canResume(){const e=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&this.layer?.loaded&&this.parent&&!this.parent.suspended&&this.view?.ready&&(0,d.g7)(e)&&this.visibleAtCurrentScale&&this.visibleAtCurrentTimeExtent||!1}getSuspendInfo(){const e=this.parent?.suspended?this.parent.suspendInfo:{};this.view?.ready||(e.viewNotReady=!0),this.layer&&this.layer.loaded||(e.layerNotLoaded=!0);const t=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return(0,d.g7)(t)&&this.visibleAtCurrentScale||(e.outsideScaleRange=!0),this.visibleAtCurrentTimeExtent||(e.outsideVisibilityTimeExtent=!0),this.visible||(e.layerInvisible=!0),e}isUpdating(){return!1}};(0,s.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"spatialReferenceSupported",null),(0,s.Cg)([(0,c.MZ)()],p.prototype,"view",void 0),(0,s.Cg)([(0,c.MZ)()],p.prototype,"fullOpacity",null),(0,s.Cg)([(0,c.MZ)()],p.prototype,"layer",void 0),(0,s.Cg)([(0,c.MZ)()],p.prototype,"parent",void 0),(0,s.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"suspended",null),(0,s.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"suspendInfo",null),(0,s.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"legendEnabled",null),(0,s.Cg)([(0,c.MZ)({type:Boolean,readOnly:!0})],p.prototype,"updating",null),(0,s.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"updatingProgress",null),(0,s.Cg)([(0,c.MZ)()],p.prototype,"updateSuspended",null),(0,s.Cg)([(0,c.MZ)()],p.prototype,"visible",null),(0,s.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"visibleAtCurrentScale",null),(0,s.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"visibleAtCurrentTimeExtent",null),p=(0,s.Cg)([(0,u.$)("esri.views.layers.LayerView")],p)},95745:(e,t,i)=>{i.d(t,{G:()=>l,S:()=>u,b:()=>c});var s=i(73398),a=i(86955),n=i(70367),r=i(31432),o=i(2687);class l extends r.Y{}function c(){const e=new o.N5;return e.include(s.c),e.fragment.uniforms.add(new n.N("splatOutputDepth",e=>e.splatDepth)),e.fragment.main.add(a.H`vec4 splatDepth = texture(splatOutputDepth, uv);
float ndcDepth = splatDepth.x;
float depthCutOff = 0.75;
if(splatDepth.a < depthCutOff) {
discard;
}
gl_FragDepth = (ndcDepth + 1.0) * 0.5;`),e}const u=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatDepthCompositionPassParameters:l,build:c},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=65984.ab8011b5.chunk.js.map